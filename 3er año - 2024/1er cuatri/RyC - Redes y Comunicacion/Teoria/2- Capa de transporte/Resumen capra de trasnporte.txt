Modelos de transporte:
Los mas usados son TCP y UDP, pero hay mas protocolos como SCTP(orientado a stream), QUIC, etc.

TCP:	(Transmission Control Protocol)
Transporte de seguro confiable, con contorl de ERRORES y EFICIENCIA. Con control de FLUJO y TRANSPORTE
Acepta secuencias de varios tamaño, con una unidad de transeferencia de segmento. Esto permite ir generando el archivo dinamicamente, lo que permite el streaming
Posee overhead para el control de flujo y congestion, errores, etc
Requiere establecer conexion y cerrar
Funciona con FTP, HTTP, SMTP, SSH
Identificador con el 6



UDP:	(User Datagram Protocol)
Transporte no confiable, minimo sobre IP
Protocolo minimalista, menor overhead
No requiere establecimiento de conexion
Posee unicamente un send y un recive
Se usa principalmente para aplicaciones agiles, servicio DNS, video, streaming, Bcast, Mcast
Identificador con el 17
Si hay un error la capa de aplicacion se encargara de retransmitir, udp no retransmite

AMBOS
Admiten MUX/DEMUX, deteccion de errores.
Se implementan mediante una API Socket, mediante llamadas al sistema operativo
Funcionan con servicio FDX


SCTP:
Tiene menos overhead que TCP pero posee oferece mas servicio que UDP
Orienteado a paquetes
Trata de mantener un secuenciamiento y de mantener la congestion de la red
Identificador con el 132





Datagrama:

	UDP: Source Port, Destination Port, Length, UDP checksum, DATA
	Header fijo 8 bytes (2 + 2 + 2 + 2)
	Total 32 Bytes (8 + 24)

	TCP: 
	Header fijo 20 Bytes. Source port, destination port, sequence number, ack number, header 	lenght, flags, windiw size, TCP checksum, urgent pointer, options (tamaño variable)
	Flags: SYN (nueva conexion), PuSH  y URGent (entrergar directamente a la app), ACK y FIN
	Por ultimo el campo DATA que es de tamaño variable






Estableciendo coneccion TCP:
	Flags: ACK, SYN, RST
	3 way handshake (3WH)
	En el 3er segmento ya se puede mandar info
	Flag RST va si ya hau un proceso en estado listen
	Dos clases de open, open Pasivo (servidor) y Activo (cliente) o open simultaneo.

	El ISN (inicial sequence number) es un contador q se incrementa cada 4mseg
	El ACK devuelve el ISN recibido + 1
	Se espera siempre en el ACK de respuesta el numero de ISN que se mando + 1
	
Forma Activa
	Cliente manda SYN (0) y ISN = X + 0			(connect())
	Server respond SYN (0), ISN = Y + 0, ACK= X +  1	(listen())
	Cliente manda ACK = Y+1 (0+)		(aca ya se podria manmdar data)
	Conexion establecida
	
	Casos erroneos
	Puede recibirse el ACK bien pero el ISN en 0, eso indicaque del otro lado no hay nadie esperando.
	Si no se recibe respuesta entra el TIMEOUT.

Open simultaneo:
	Eas cuadno ambos lados ejecutan el 3WH de forma activa entonces ambos lados pueden recibir y mandar info de forma simultanea



Cerrado de conexion:
	Activo con shutdown() / close() => FIN(0+), seq = W, ACK = V
	Pasivo entonces EOF to APP y RES => ACK = W+1 (0+)
	FIN_WAIT_1	(aca ya se cerro la conexion del cliente ,este no puede mandar mas datos)

	Aca todavia el servidor puede mandarle data el cliente, el cliente espera por el FIN_WAIT_2

	Pasivo/server con shutdown() / close() crea el LAST_ACK => FIN(0+), seq=X, ACK=W+1
	Cliente recibe el FIN_WAIT_2 => RES ACK=H+N+1(0) y hace TIME_WAIT(2MSL)
	Server closed
	
Ahora si la conexion esta cerrada por los 2





PUSH vs URG (urgent)
	Sirven para lo mismo, para que el server mande a la app directamente la info, sin esperar la totalidad de la info
	El PUSH ide la importancia unicamente para el paquete mandado.
	El URG lo pide para todoslos paquetes a partir del URG
	El URG indica una direccion a partir de la cual se le da importancia



OPTIONS del TCP
	Opciones que se pueden mandar en el campo OPTIONS del TCP
	MSS (Maximum Segment Size): indica cual es el tamaño maximo que puede enviar, el tamaño se 	define segun el MTU (Maximum Transfer Unit)

	TimeStamping: para poder calcular un mejor RTT (Round Trip Time) que sirve para calcular 	mejor el RTO (Retransmition Time OUT)
	Selective ACK (SACK), window scaling, NOP (No Operating), etc.
	
