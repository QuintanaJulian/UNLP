Practica 2, todos los ejercicios.

1-
Existen N personas que deben ser chequeadas por un detector de metales antes de poder
ingresar al avión
A-B-
Implemente una solución que modele el acceso de las personas a un detector (es decir,
si el detector está libre la persona lo puede utilizar; en caso contrario, debe esperar).

sem  mutex = 1;

Process [id: 0..N-1] {
	P(mutex)
	//pasar por detector
	V(mutex)
	//ingresa al avion 
}


C-
Modifique su solución para el caso que haya tres detectores. 

sem mutex = 3;

Process [id: 0..N-1] {
	P(mutex)
	//Pasar pro el detector
	V(mutex)
	//ingresar al avion
}


2-
Un sistema de control cuenta con 4 procesos que realizan chequeos en forma
colaborativa. Para ello, reciben el historial de fallos del día anterior (por simplicidad, de
tamaño N). De cada fallo, se conoce su número de identificación (ID) y su nivel de
gravedad (0=bajo, 1=intermedio, 2=alto, 3=crítico). Resuelva considerando las siguientes
situaciones:

A-
Se debe imprimir en pantalla los ID de todos los errores críticos (no importa el orden).

cola datos;
sem mutex = 1

Process [n: 0..3] {
	int id, gravedad

	P(mutex)
	while (NOT empty datos)
		Pop (datos, (id, datos))
		V(mutex)
		Console.log(id);
		P(mutex)
	}
	V(mutex)
	
}


B-
Se debe calcular la cantidad de fallos por nivel de gravedad, debiendo quedar los
resultados en un vector global.

cola datos;
sem mutex = 1
int cont[4] = (0..3: 0)
sem acceso[4] = (0..3 = 1)

Process [n: 0..3] {
	int id, gravedad

	P(mutex)
	while (NOT empty datos)
		Pop (datos, (id, grevedad))
		V(mutex)
		P (acceso[gravedad])
		cont[gravedad] = cont[gravedad] + 1;	
		V (acceso[gravedad])
		P(mutex)
	}
	V(mutex)
	
}


C-
Ídem b) pero cada proceso debe ocuparse de contar los fallos de un nivel de gravedad determinado.

cola datos;
sem mutex = 1
int cont[4] = (0..3: 0)

Process [n: 0..3] {
	int id, gravedad

	P(mutex)
	while (NOT empty datos)
		Pop (datos, (id, grevedad))
		V(mutex)
		
		if (gravedad = n){
			cont[gravedad] = cont[gravedad] + 1;	
		} else {
			P(mutex)
			Push(datos, (id, datos))
			V(mutex)
		}
		
		P(mutex)
	}
	V(mutex)
	
}


3-
Un sistema operativo mantiene 5 instancias de un recurso almacenadas en una cola.
Además, existen P procesos que necesitan usar una instancia del recurso. Para eso, deben
sacar la instancia de la cola antes de usarla. Una vez usada, la instancia debe ser encolada nuevamente. 


cola SO;
sem mutex = 1;
sem datosDispo = 4;


Process Instancias [n: 0..N-1] {
	text datos;	
	
	while (true) {
		P (datosDispo);
		P(mutex)
		Pop (SO, datos);
		V(mutex)
		
		UsarDatos (datos);

		P(mutex)
		Push (SO, datos);
		V(mutex)
		V(datosDispo)
	}	
	
}



4-
Suponga que existe una BD que puede ser accedida por 6 usuarios como máximo al
mismo tiempo. Además, los usuarios se clasifican como usuarios de prioridad alta y
usuarios de prioridad baja. Por último, la BD tiene la siguiente restricción:
• no puede haber más de 4 usuarios con prioridad alta al mismo tiempo usando la BD.
• no puede haber más de 5 usuarios con prioridad baja al mismo tiempo usando la BD.
Indique si la solución presentada es la más adecuada. Justifique la respuesta. 


sem DB = 6;
sem altaPrio = 4;
sem bajaPrio = 5;

Process usuario [0..N] {
	prioridad = getPrioridad();
	
	if (prioridad = "alta") {
		P(altaPrio)
	} else { P(bajaPrio) }
	
	P(DB);

	//usar DB

	V(DB)

	if (prioridad = "alta") {
		V(altaPrio)
	} else { V(bajaPrio) }	
}




5-
En una empresa de logística de paquetes existe una sala de contenedores donde se
preparan las entregas. Cada contenedor puede almacenar un paquete y la sala cuenta con
capacidad para N contenedores. Resuelva considerando las siguientes situaciones.

A-
La empresa cuenta con 2 empleados: un empleado Preparador que se ocupa de
preparar los paquetes y dejarlos en los contenedores; un empelado Entregador
que se ocupa de tomar los paquetes de los contenedores y realizar la entregas.


text contenedor [N];
int dimL: -1;
sem dispos = 0;
sem mutex = 1;
sem unPaqueteMenos = 0;

Process Preparador () {
	text datos;

	while (true) {
		datos = getNuevoPaquete();
		while (dimL = (N-1)) { P(unPaqueteMenos }
		P(mutex)
		dimL = dimL + 1;
		contenedor [dimL] = datos;
		V (mutex)
		V (dispos)		

	}

}


Process Entregador () {
	text datos;
	
	while (true) {
		P (dispos);
		P (mutex)
		if (dimL = (N-1)) { P(unPaqueteMenos) }
		datos = contenedor [dimL];
		dimL --;
		V (mutex)
		EntregarPaquete (datos)
	}
}

B-
Modifique la solución a) para el caso en que haya P empleados Preparadores.

text contenedor [N];
int dimL: -1;
sem dispos = 0;
sem mutex = 1;
sem unPaqueteMenos = 0;

Process Preparador (p: 0..P-1) {
	text datos;

	while (true) {
		datos = getNuevoPaquete();
		
		P(mutex)
		while (dimL = (N-1)) { 
			V(mutex)
			P(unPaqueteMenos)
			P (mutex)
		}
		
		dimL = dimL + 1;
		contenedor [dimL] = datos;
		V (mutex)
		V (dispos)		
	}
}


Process Entregador () {
	text datos;
	
	while (true) {
		P (dispos);
		P (mutex)
		if (dimL = (N-1)) { V(unPaqueteMenos) }
		datos = contenedor [dimL];
		dimL --;
		V (mutex)
		EntregarPaquete (datos)
		
	}
}

C-
Modifique la solución a) para el caso en que haya E empleados Entregadores

text contenedor [N];
int dimL: -1;
sem dispos = 0;
sem mutex = 1;
sem unPaqueteMenos = 0;

Process Preparador () {
	text datos;

	while (true) {
		datos = getNuevoPaquete();
		while (dimL = (N-1)) { P(unPaqueteMenos }
		P(mutex)
		dimL = dimL + 1;
		contenedor [dimL] = datos;
		V (mutex)
		V (dispos)		

	}

}


Process Entregador [e: 0..E-1] {
	text datos;
	
	while (true) {
		P (dispos);
		P (mutex)
		if (dimL = (N-1)) { P(unPaqueteMenos) }
		datos = contenedor [dimL];
		dimL --;
		V (mutex)
		EntregarPaquete (datos)
		
	}
}


D- Modifique la solución a) para el caso en que haya P empleados Preparadores y E
empleadores Entregadores

text contenedor [N];
int dimL: -1;
sem dispos = 0;
sem mutex = 1;
sem unPaqueteMenos = 0;

Process Preparador (p: 0..P-1) {
	text datos;

	while (true) {
		datos = getNuevoPaquete();
		
		P(mutex)
		while (dimL = (N-1)) { 
			V(mutex)
			P(unPaqueteMenos)
			P (mutex)
		}
		
		dimL = dimL + 1;
		contenedor [dimL] = datos;
		V (mutex)
		V (dispos)		
	}
}


Process Entregador () {
	text datos;
	
	while (true) {
		P (dispos);
		P (mutex)
		if (dimL = (N-1)) { V(unPaqueteMenos) }
		datos = contenedor [dimL];
		dimL --;
		V (mutex)
		EntregarPaquete (datos)
		
	}
}



6-
Existen N personas que deben imprimir un trabajo cada una. Resolver cada ítem usando semáforos

A-
Implemente una solución suponiendo que existe una única impresora compartida por
todas las personas, y las mismas la deben usar de a una persona a la vez, sin importar
el orden. Existe una función Imprimir(documento) llamada por la persona que simula el
uso de la impresora. Sólo se deben usar los procesos que representan a las Personas.

sem mutex = 1;


Process Persona [id: 0..N-1] {
	text documento: getDocumento()
	
	P(mutex);
	Imprimir (documento)
	V (mutex)
}

B- 
Modifique la solución de (a) para el caso en que se deba respetar el orden de llegada.

sem mutex = 1;
cola colaEspera;
sem turno[N] = (0..N-1 : 0)
boolean libre = true;


Process Persona [id: 0..N-1] {
	text document:  getDocument()
	int user;	

	P(mutex)
	if (not libre) {
		Push (colaEspera, id)
		V (mutex)	
		P(turno[id])
		P(mutex)
	}
	libre = false;
	V(mutex)

	Imprimir (documento)
	
	P(mutex)
	if (empty (colaEspera)) {
		libre = true
	} else {
		Pop (colaEspera, user)
		V(turno[user])
	}
	V(mutex)
}



C-
Modifique la solución de (a) para el caso en que se deba respetar estrictamente el
orden dado por el identificador del proceso (la persona X no puede usar la impresora
hasta que no haya terminado de usarla la persona X-1).

sem turno [N]: (0: 1, 1..N-1: 0)		//no se si se puede incicializa asi, si no habria que poner un if de si sos id 0

Process Persona [id: 0..N-1] {
	text documento: getDocumento()
	
	P(turno [id]);
	Imprimir (documento)
	V (turno [id+1]);
}


D-
Modifique la solución de (b) para el caso en que además hay un proceso Coordinador
que le indica a cada persona que es su turno de usar la impresora.

sem mutex: 1;
cola colaEspera;
sem turno [N]: (0..N-1: 0)
sem nuevoPedido: 0;
sem ready = 0;

Process Persona [id: 0..N-1] {
	text documento: getDocumento()

	P (mutex)
	Push (colaEspera, id)
	V (mutex)
	V (nuevoPedido);

	
	P(turno [id]);
	Imprimir (documento)
	V (ready)
}

Process Coordinador {
	int user;

	while (true) {
		P(nuevoPedido);
		P (mutex)
		Pop (colaEspera, user),
		V (mutex)

		V(turno[user])
		P (ready)
	}
}



C-
Modificar la solución (d) para el caso en que sean 5 impresoras. El coordinador le
indica a la persona cuando puede usar una impresora, y cual debe usar. 


sem mutex: 1;
cola colaEspera;
sem turno [N]: (0..N-1: 0)
sem nuevoPedido: 0;
sem ready = 0;
sem impresoraDispo = 5;

Process Persona [id: 0..N-1] {
	text documento: getDocumento()

	P (mutex)
	Push (colaEspera, id)
	V (mutex)
	V (nuevoPedido);

	
	P(turno [id]);
	Imprimir (documento)
	V (ipresoraDispo)
}

Process Coordinador {
	int user;

	while (true) {
	
		P(nuevoPedido);
		P (mutex)
		Pop (colaEspera, user),
		V (mutex)
		
		P(impresoraDispo)
		V(turno[user])
	}
}


7-
Suponga que se tiene un curso con 50 alumnos. Cada alumno debe realizar una tarea y
existen 10 enunciados posibles. Una vez que todos los alumnos eligieron su tarea,
comienzan a realizarla. Cada vez que un alumno termina su tarea, le avisa al profesor y se
queda esperando el puntaje del grupo, el cual está dado por todos aquellos que comparten
el mismo enunciado. Cuando un grupo terminó, el profesor les otorga un puntaje que
representa el orden en que se terminó esa tarea de las 10 posibles.

Nota: Para elegir la tarea suponga que existe una función elegir que le asigna una tarea a un alumno (esta función asignará 10 tareas diferentes entre 50 alumnos, es decir, que 5 alumnos tendrán la tarea 1, otros 5 la tarea 2 y así sucesivamente para las 10 tareas)


sem mutex = 1;
sem arrancar = 0;
int presentes = 0;

cola terminados;
sem termino: 0;
sem resultadoListo[50] : (0..49: 0)
int resultado[11];

Process Alumno [id: 0..49] {
	int grupo: elegir();
	int nota;	

	P (mutex)
	presentes = presentes + 1;
	if (presentes = 50) {
		for 1..50 {V (arrancar)}
	}
	V (mutex)

	P (arrancar)
	
	HacerTarea(grupo);
	
	P (mutex)
	Pop (terminados, (id, grupo);
	V (mutex)
	P(termino)

	P (resultadoListo [grupo]);
	nota = resultado[grupo];
}


Process Profesor {
	int entregaron[11]: (0..10: 0);
	int alumno, grupo;
	int pos: 1;
	int alumnosEntregaron: 0;
	
	while (alumnosEntregaron < 50) {
		P(termino)
		P (mutex)
		Pop (terminados, (alumno, grupo));
		V (mutex)

		entregaron[grupo] = entregaron[grupo] + 1;
		if (entregaron[grupo] = 5){
			resultado[grupo] = pos;
			pos ++;
			V (resultadoListo[grupo])
		}
		alumnosEntregaron ++;
	}
}




8-
Una fábrica de piezas metálicas debe producir T piezas por día. Para eso, cuenta con E
empleados que se ocupan de producir las piezas de a una por vez (se asume T>E). La
fábrica empieza a producir una vez que todos los empleados llegaron. Mientras haya
piezas por fabricar, los empleados tomarán una y la realizarán. Cada empleado puede
tardar distinto tiempo en fabricar una pieza. Al finalizar el día, se le da un premio al
empleado que más piezas fabricó.


int llegaron = 0;
sem arrancar = 0;

sem mutex = 1
int piezasActuales = 0

int piezasEmpleados[E] = (0..N-1: 0)

boolean premio = false;

process Empleado [id: 0..E-1]{
	P(mutex)
	llegaron ++;
	if (llegaron = E) {
		for 1..50 {V(arrancar)}
	}
	V(mutex)

	P(arrancar)

	P(mutex)
	while (piezasActuales < T){
		piezasActuales++;
		V(mutex)
		
		piezasEmpleados[id] = piezasEmpleados[id] + 1;
		ProducirPieza()

		P(mutex)
	}
	V(mutex)

	if ((piezasActuales = T) and not premio) {
		for 0..E {
		
	}
	
}



9-
Resolver el funcionamiento en una fábrica de ventanas con 7 empleados (4 carpinteros, 1
vidriero y 2 armadores) que trabajan de la siguiente manera:
• Los carpinteros continuamente hacen marcos (cada marco es armando por un único
carpintero) y los deja en un depósito con capacidad de almacenar 30 marcos.
• El vidriero continuamente hace vidrios y los deja en otro depósito con capacidad para
50 vidrios.
• Los armadores continuamente toman un marco y un vidrio (en ese orden) de los
depósitos correspondientes y arman la ventana (cada ventana es armada por un único
armador).


sem acceso_marcos = 1;
int tam_marcos = 0;
sem espacio_marcos = 0;
sem deposito_marcos = 0;

sem acceso_vidrios = 1;
int tam_vidrios = 0;
sem espacio_vidrios = 0;
sem deposito_vidrios = 0;



Process Carpintero [id: 0..3] {
	
	
	while true {
		HacerMarco();
		P(acceso_marcos)
		if (tam_marcos = 30) {
			V(acceso_marcos)
			P(espacio_marcos)
			P(acceso_marcos)
		}
		GuardarMarco()
		tam_marcos = tam_marcos + 1;
		V(deposito_marcos)
		V(acceso_marcos)
	}
	
}


Process Vidriero {
	while (true) {
		HacerMarco();
		P (acceso_vidrios) 
		if (tam_vidrios = 50){
			V(acceso_vidrios);
			P (espacio_vidrios)
			P (acceso_vidrios);
		}
		GuadarVidrio()
		tam_vidrios = tam_vidrios + 1;
		V(deposito_vidrios);
		V (acceso_vidrios)
	}
}

Process Armadores [id: 0..1] {
	while (true) {
		P(deposito_marcos)
		P(aceso_marcos)
		TomarMarcos()
		if (tam_marcos = 30) {
			V(espacio_marcos)
		}
		tam_marcos = tam_marcos - 1;
		V (acceso_marcos)
		
		P(deposito_vidrios)
		P(acceso_vidrios)
		TomarVidrios()
		if (tam_vidrios  = 50){
			V(espacio_vidrios)
		}
		tam_vidrios= tam_vidrios - 1;
		V (acceso_vidrios)
		

		ArmarVentana()
	}
}




10-
A una cerealera van T camiones a descargarse trigo y M camiones a descargar maíz. 
Sólo hay lugar para que 7 camiones a la vez descarguen, pero no pueden ser más de 5 del mismotipo de cereal. 
Nota: no usar un proceso extra que actué como coordinador, resolverlo entre los camiones.


sem entradas: 7;
sem maiz:  5;
sem trigo: 5;

Process CamionT [n: 0..T-1]{
	P(trigo)
	P(entradas)
	DescargandoCamion()
	V(entradas)
	V (trigo)
	
	
}


Process CamionM [n: 0..M-1] {
	P(maiz)
	P(entradas)
	DescargandoCamion()
	V(entradas)
	V (maiz)
	
}



11-
En un vacunatorio hay un empleado de salud para vacunar a 50 personas. El empleado
de salud atiende a las personas de acuerdo con el orden de llegada y de a 5 personas a la
vez. Es decir, que cuando está libre debe esperar a que haya al menos 5 personas
esperando, luego vacuna a las 5 primeras personas, y al terminar las deja ir para esperar
por otras 5. Cuando ha atendido a las 50 personas el empleado de salud se retira. 
Nota: todos los procesos deben terminar su ejecución; 
asegurarse de no realizar Busy Waiting;
suponga que el empleado tienen una función VacunarPersona() que simula que el empleado está vacunando a UNA persona. 


cola colaEspera;
int dimL: 0;
sem turno[50]: (0..49: 0)
sem mutex: 1;
sem termino[50]: (0..49: 0)
sem mutex: 0;
int total: 0;

Process Persona [id: 0..49] {
	P (mutex);
	Push (colaEspera, id)
	dimL ++;
	if (dimL >= 5) V(masQue5)
	total = total + 1;
	V (mutex)
	
	P(turno[id])
	//siendo vacunada
	P(termino[id])

}



Process Empleado {
	int atendidos[5];	
	int n;

	while total > 50 {
		while (dimL < 5) {P(masQue5)}
		P (mutex)
		for n:0..4 {
			dimL--;
			Pop (colaEspera, id)
			atendido[n] = id;
			V(turno[id])
		}
		V (mutex)
		for 0..4 {
			VacunarPersona()
		}
		
		for n:0..4 {
			V(termino[atendido[n]]);
		}
	}
}







12-
Simular la atención en una Terminal de Micros que posee 3 puestos para hisopar a 150 
pasajeros. En cada puesto hay una Enfermera que atiende a los pasajeros de acuerdo
con el orden de llegada al mismo. Cuando llega un pasajero se dirige al puesto que tenga
menos gente esperando. Espera a que la enfermera correspondiente lo llame para
hisoparlo, y luego se retira. Nota: sólo deben usar procesos Pasajero y Enfermera.
Además, suponer que existe una función Hisopar() que simula la atención del pasajero por
parte de la enfermera correspondiente. 


sem mutex: 1;
int dimL[3]: (0..2 : 0)
cola listaEspera[3];
sem usando[3]: (0..2: 0)
sem turno[150]: (0..149: 0)
sem termino[150]: (..149: 0)
sem llegoPasajero[3]: (0..2: 0);

Process Pasajero [id: 0..149] {
	int minimo: 99999;
	int n, n_minimo;
	P(mutex)
	for n:0..2 {
		if dimL[n] < minimo {
			minimo = dimL[n]
			n_minimo = n
		}
	}
	P(usando[n_minimo])
	V(mutex)

	Push (listaEspera[n_minimo], id);
	V(llegoPasajero[n_minimo])

	P(turno[id])
	//Esta siendo Hisopado
	P(termino[id])
}



Process Terminal [n: 0..2] {
	int id;

	while (true) {
		P(llegoPasajero[n])
		P(usando[n])
		Pop  (listaEspera[n], id)
		V(usando[n])
		V(turno[id])
		Hisopar()
		V(termino[id]);
	}	
}
















