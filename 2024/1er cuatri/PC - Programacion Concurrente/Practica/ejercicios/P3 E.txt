P3 E

E 2- 

Monitor BD {
	cond cola;
	atendiendo = 0;

	Procedure acceder (){
		while (atendiendo >= 5) wait (cola);	
		atendiendo = atendiendo + 1
		
		//if (atendiendo <= 5) wait(cola)
		//atendiendo = atendiendo + 1
	}

	Procedure salir(){
		atendiendo = atendiendo - 1;
		signal (cola)
		
	}	

}	



Process [p:1..N] {
	DB.acceder()

	//Usar la DB
	
	DB.salir()

}


Ej 3- 
Existen N personas que deben fotocopiar un documento. La fotocopiadora sólo puede ser
usada por una persona a la vez. Analice el problema y defina qué procesos, recursos y
monitores serán necesarios/convenientes, además de las posibles sincronizaciones requeridas
para resolver el problema. 

A-B-
Monitor Impresora {
	cond espera;
	int nEspera = 0;
	boolean libre = true;
	
	Procedure solicitar () {
		if (not libre) {
			nEspera = nEspera + 1;
			wait (espera);
		}
		libre = false;
	}

	Procedure liberar () {
		if (nEspera > 0) {
			nEspera = nEspera - 1
			signal (cola)
		} else libre = true

	}
}

Process Usuario [id: 1..N-1] {
	Impresora.solicitar()
	Fotocopiar()
	Impresora.liberar()	
}


C-
Dar prioridad por edad, mas grande mayor prioridad

Monitor Impresora {
	cond espera[N];
	colaOrdenada cola;
	//int nEspera = 0;
	boolean libre = true;
	
	Procedure solicitar (int IN id, int IN edad) {
		if (not libre && not empty(cola) {
			Push (cola, (edad, id));
			wait (espera[id]);
		}
		libre = false;
	}

	Procedure liberar () {
		int edad, id;
		if (not empty(cola)) {
			Pop (cola (edad, id))
			signal (espera[id]))
		} else libre = true

	}
}

Process Usuario [id: 1..N-1] {
	int edad = getEdad();
	Impresora.solicitar(id, edad)
	Fotocopiar()
	Impresora.liberar()	
}


D- 
Se debe usar estrictamente segun el numero de proceso



Monitor Impresora {
	cond turno[N];
	int nTurno= 0;
	
	Procedure solicitar (int IN id) {
		if (not  nTurno = id ) {
			wait (turno[id]);
		}
	}

	Procedure liberar () {
		nTurno = nTurno + 1;
		signal [nTurno];
	}
}

Process Usuario [id: 1..N-1] {
	Impresora.solicitar(id)
	Fotocopiar()
	Impresora.liberar()	
}


E- 
Modificar el B par que haya un empleado que indique cuando usar la impresoram

Monitor administrador {
	cola colaEspera;
	cond listaEspera[N];
	cond llegoNuevo;


	Procedure pedirImprimir(int IN id, text IN datos){
		push (colaEspera, (id, datos))
		signal (llegoNuevo)
		wait (listaEspera[id]);
			
	}

	Procedure solicitarPedido (int OUT id, text OUT datos) {
		int id;
		if(empty colaEspera()) wait(llegoNuevo)
		Pop (colaEspera, (id, datos))
		
	}

	Procedure terminarPedido (int IN id) {
		signal (listaEspera[id])
	}

}




Process impresora () {
	int id;
	text datos;
	while (true){
		impresora.solicitarPedido(id, datos);
		Fotocopiar(datos);
		impresora.terminarPedido(id);
	}
}

Process usuario [id: 0..N-1] {
	datos: getDatosImpresion();
	administrador.pedirImprimir (id, datos);

}


F- 
Modificamos el anterior para que ahora haya 10 impresoras


Monitor administrador {
	cola colaEspera;
	cond listaEspera[N];
	cond llegoNuevo;

	Procedure pedirImprimir(int IN id, text IN datos){
		push (colaEspera, (id, datos))
		signal (llegoNuevo)
		wait (listaEspera[id]);
			
	}

	Procedure solicitarPedido (int OUT id, text OUT datos) {
		int id;
		while (empty colaEspera()) wait(llegoNuevo)
		Pop (colaEspera, (id, datos))
		
	}

	Procedure terminarPedido (int IN id) {
		signal (listaEspera[id])
	}

}




Process impresora [n: 0..9] {
	int id;
	text datos;
	while (true){
		impresora.solicitarPedido(id, datos);
		Fotocopiar(datos);
		impresora.terminarPedido(id);
	}
}

Process usuario [id: 0..N-1] {
	datos: getDatosImpresion();
	administrador.pedirImprimir (id, datos);

}


4-
Existen N vehículos que deben pasar por un puente de acuerdo con el orden de llegada. 
Considere que el puente no soporta más de 50000kg y que cada vehículo cuenta con su propio
peso (ningún vehículo supera el peso soportado por el puente).

Monitor Puente {
	cond listaEspera;
	cola colaEspera;
	int pesoActual = 0;
	cond llegoVehiculo;
	cond pasoVehiculo;

	Procedure solicitarPasar (int IN id, int IN peso){
		Push (colaEspera (id, peso);
		signal (llegoVehiculo)
		wait (listaEspera)		

	}

	Procedure siguienteVehiculo () {
		int id, peso;
		if (not empty(colaEspera)) wait (llegoVehiculo)
		Pop (colaEspera, ( id, peso))
		while ((peso + pesoActual) > 50000) await (pasoVehiculo)
		pesoActual= pesoActual + peso;
		signal (listaEspera);
	}	

	Procedure terminoPasar (int IN peso){
		pesoActual = pesoActual - peso;
		signal (pasoVehiculo)
	}
	
}


Process vehiculo [id: 0..N-1] {
	peso = getPeso()
	Puente.solicitarPasar(id, peso);
	PasandoPuente();
	Puente.terminoPasar(peso);
}

Process empleado {
	while (true){
		Puente.siguienteVehiculo();
	}
}


5-
En un corralón de materiales se deben atender a N clientes de acuerdo con el orden de llegada.
Cuando un cliente es llamado para ser atendido, entrega una lista con los productos que
comprará, y espera a que alguno de los empleados le entregue el comprobante de la compra
realizada.

a) Resuelva considerando que el corralón tiene un único empleado.


Monito Corralon {

	cola colaEspera; 
	cond turno[N];	
	cond llegoCliente;
	text listaPedido;
	cond envioPedido[N]
	cond respuesta[N]
	text listaComprobante;
	cond abandonaCliente;
	
	Procedure llegar(int IN id) {
		Push (colaEspera,id);
		signal (llegoCliente);
		wait (turno[id]);
		
	}


	Procedure entregarPedido(int IN id, text IN pedido, text OUT comprobante){
		listaPedido = pedido;
		signal (envioPedido[id]);
		await (respuesta[id])
		comprobante = listaComprobante;
		signal (abandonaCliente);
	}	
	

	Procedure siguientePedido (int OUT id, text OUT pedido){
		wait (llegoCliente);
		Pop (colaEspera, id)
		signal (turno[id])
		
		await (envioPedido[id]);
		pedido = listaPedido;		
		
	}


	Procedure mandarComprobante (int IN id, text IN comprobante){
		listaComprobante = comprobante;
		signal (respuesta[id])
		wait (abandonaCliente)
		
		
	}
	
}




Process Cliente [id: 0..N-1] {
	text pedido: getPedido()
	text comrpobante;

	Corralon.llegar(id)
	Corralon.entregarPedido(id, pedido, comprobante)
}


Process Empleado {
	int cliente;
	text pedido;
	text comprobante;


	while (true) {
		Corralon.siguientePedido(cliente, pedido);
		CrearPedido (pedido, comprobante)
		Corralon.mandarComprobante (cliente, comprobante);
	}
}


B-
Resuelva considerando que el corralón tiene E empleados (E > 1).

Monito Corralon {

	cola colaEspera; 
	cond turno[N];	
	cond llegoCliente;
	text listaPedido[N];
	cond envioPedido[N]
	cond respuesta[N]
	text listaComprobante[N];
	cond abandonaCliente[N];
	
	Procedure llegar(int IN id) {
		Push (colaEspera,id);
		signal (llegoCliente);
		wait (turno[id]);
		
	}


	Procedure entregarPedido(int IN id, text IN pedido, text OUT comprobante){
		listaPedido = pedido;
		signal (envioPedido[id]);
		await (respuesta[id])
		comprobante = listaComprobante[id];
		signal (abandonaCliente[id]);
	}	
	

	Procedure siguientePedido (int OUT id, text OUT pedido){
		wait (llegoCliente);
		Pop (colaEspera, id)
		signal (turno[id])
		
		await (envioPedido[id]);
		pedido = listaPedido[id];		
		
	}


	Procedure mandarComprobante (int IN id, text IN comprobante){
		listaComprobante[id] = comprobante;
		signal (respuesta[id])
		wait (abandonaCliente[id])
	}
	
}




Process Cliente [id: 0..N-1] {
	text pedido: getPedido()
	text comrpobante;

	Corralon.llegar(id)
	Corralon.entregarPedido(id, pedido, comprobante)
}


Process Empleado {
	int cliente;
	text pedido;
	text comprobante;


	while (true) {
		Corralon.siguientePedido(cliente, pedido);
		CrearPedido (pedido, comprobante)
		Corralon.mandarComprobante (cliente, comprobante);
	}
}





6-
Existe una comisión de 50 alumnos que deben realizar tareas de a pares, las cuales son
corregidas por un JTP. Cuando los alumnos llegan, forman una fila. Una vez que están todos
en fila, el JTP les asigna un número de grupo a cada uno. Para ello, suponga que existe una
función AsignarNroGrupo() que retorna un número “aleatorio” del 1 al 25.
Cuando un alumno ha recibido su número de grupo, comienza a realizar su tarea. Al terminarla, el alumno le avisa
al JTP y espera por su nota. Cuando los dos alumnos del grupo completaron la tarea, el JTP
les asigna un puntaje (el primer grupo en terminar tendrá como nota 25, el segundo 24, y así
sucesivamente hasta el último que tendrá nota 1). Nota: el JTP no guarda el número de grupo
que le asigna a cada alumno.




Monitor Comision {
	int llegaron: 0;
	cola listaEspera;
	cond estanTodos;

	cond asigGrupo[50];
	int numGrupo[50];

	int termino [25];
	cola terminados;	//grupo id, id
	cond tareaTerminada;
	
	cond respuesta[25]
	int notas [25];
	
	


	Procedure llego (int IN id, int OUT grupo){
		Push (listaEspera, id)
		llegaron ++;
		if (llegaron = 50) {
			signal (estanTodos);
		}
		wait (asigGrupo[id]);
		grupo = numGrrupo[id];
	}


	Procedure entregarTarea(int IN grupo, text IN tarea, int OUT nota){
		termino[grupo] = termino[grupo] + 1;
		if (termino[grupo] = 2){
			Push (terminados, (grupo, tarea))
			signal (tareaTerminada);			
		}
		wait (respuesta[grupo])
		nota = notas[grupo]
	}


	Procedure esperarAlumnos() {
		wait (estanTodos)
	}


	Procedure getAlumno (int OUT id){
		Pop (listaEspera, id)
	}

	Procedure setGrupo (int IN id, int IN grupo){
		numGrupo[id] = grupo;
		wait (asigGrupo[id]);
	}

	Procedure corregirTarea (int OUT grupo, text OUT tarea) {
		wait (tareaTerminada);
		Pop (terminados, (grupo, tarea);
	}
	
	Procedure setNota (int IN grupo, int IN nota){
		notas[grupo]= nota;
		signal_all [grupo];

	}

	
}



Process Alumno [id: 0..49]{
	int grupo, nota;
	text tarea;
	

	Comision.llego(id, grupo);
	HacerTarea();
	Comision.entregarTarea(grupo, tarea, nota);
}



Process JTP {
	int alumnosCorregidos = 0;
	int notaActual: 25;
	int alumno, grupo, nota;
	text tarea;
	
	monitor.esperarAlumnos();
	
	for 1..50 {
		Comision.getAlumno(alumno)
		AsignarNroGrupo()
		Comision.setGrupo(alumno, grupo)	
	}

	for 1..50 {
		Comision.corregirTarea(grupo, tarea)
		nota = notaActual
		notaActual --;
		Comision.setNota(grupo, nota);
	}	


}





7-
En un entrenamiento de fútbol hay 20 jugadores que forman 4 equipos (cada jugador conoce
el equipo al cual pertenece llamando a la función DarEquipo()). Cuando un equipo está listo
(han llegado los 5 jugadores que lo componen), debe enfrentarse a otro equipo que también
esté listo (los dos primeros equipos en juntarse juegan en la cancha 1, y los otros dos equipos
juegan en la cancha 2). Una vez que el equipo conoce la cancha en la que juega, sus jugadores
se dirigen a ella. Cuando los 10 jugadores del partido llegaron a la cancha comienza el partido,
juegan durante 50 minutos, y al terminar todos los jugadores del partido se retiran (no es
necesario que se esperen para salir).

Monitor Equipo {
	int juadoresEquipo[4]: (0..3:0)
	cond equipoCompleto[4]
	int canchaEquipo[4]
	int canchaActual: 1;
	int equiposCompletos: 0;
	
	Procedure PedirCancha (int IN n_equipo,int OUT n_cancha){
		jugadoresEquipo[n_equipo] = jugadoresEquipo[n_equipo] +1;
		if (jugadoresEquipo[n_equipo] = 5){
			equiposCompletos++;
			signal_all (equipoCompleto[n_equipo]
			canchaEquipo[n_equipo] = canchaActual;
			if (equiposCompletos = 2){ canchaActual++;}		
		} else wait (equipoCompleto[n_equipo]
		
		n_cancha = canchaEquipo[n_equipo];
	}

}

Monitor Cancha [c: 0..1]{
	int jugadores: 0;
	cond estanJugadores;
	cond empezarPartido;
	cond terminarPartido;	

	Procedure irCancha () {
		jugadores++;
		if (jugadores = 10){
			signal(estanJugadores)
		}
		wait (empezarPartido)
		JugandoPartido()
		wait (terminarPartido)

	}


	Procedure empezarPartido (){
		if (jugadores < 10) wait(estanJugadores)
		signal_all(empezarPartido)		
	}

	Procedure terminarPartido {
		signal_all(terminarPartido)
	}

}

Process Partido [p: 0..1]{
	Cancha[p].empezarPartido();
	delay (50mins);
	Cancha[p].terminarPartido();
}



Process Jugador [id: 0..19]{
	int n_equipo, n_cancha;
	

	DarEquipo(n_equipo);
	Equipo.pedirCancha(n_equipo, n_cancha);

	Cancha[n_cancha].irCancha();
}






8-
Se debe simular una maratón con C corredores donde en la llegada hay UNA máquina
expendedoras de agua con capacidad para 20 botellas. Además, existe un repositor encargado
de reponer las botellas de la máquina. Cuando los C corredores han llegado al inicio comienza
la carrera. Cuando un corredor termina la carrera se dirigen a la máquina expendedora, espera
su turno (respetando el orden de llegada), saca una botella y se retira. Si encuentra la máquina
sin botellas, le avisa al repositor para que cargue nuevamente la máquina con 20 botellas;
espera a que se haga la recarga; saca una botella y se retira. Nota: mientras se reponen las
botellas se debe permitir que otros corredores se encolen. 





















