Explicacion 3

Ej 2-
Existen N personas que desean utilizar un cajero automático. Se debe tener en cuenta el orden de llegada de las personas. Suponga que hay una función UsarCajero() que simula el uso del cajero.

Monitor Cajero () {
	cond colaEspera;
	int tamañoCola = 0;
	boolean libre = true;
	
	Procedure llegaCajero (){
		if (not libre) await {
			tamañoCola = tamañoCola + 1;
			(colaEspera)
		}
		libre = false;
		
	}

	Procedure salirCajero () {
		if (tamañoCola = 0) libre = true
		else {	tamañoCola = tamañoCola - 1;
			signal (colaEspera)
			
		}
	}
}

Process Usuario (ID= 1..N-1){
	Cajero.llegaCajero();
	UsarCajero()
	Cajero.salirCajero();
}

Ej 3-
Partiendo de la solución anterior hacemos una cambio en el enunciado, agregando que si llega una persona anciana tiene prioridad.

Monitor Cajero () {
	cond colaEspera;
	int tamañoCola = 0;
	cond colaEsperaAnciano;
	int tamañoColaAnciano = 0;
	boolean libre = true;
	
	Procedure llegaCajero (boolean IN esAnciano){
		if (not libre) {
			if (esAnciano) {
				tamañoColaAnciano = tamañoColaAnciano + 1;
				await (colaEsperaAnciano)
			else {
				tamañoCola = tamañoCola + 1;
				await (colaEspera)
			}
		}
		libre = false;
		
	}

	Procedure salirCajero () {
		if (tamañoColaAnciano > 0) {
			tamañoColaAnciano = tamañoColaAnciano - 1;
			signal (colaEsperaAnciano)
		else if (tamañoCola > 0) {
			tamañoCola = tamañoCola - 1
			signal (colaEspera)
		} else libre = true
	}
}

Process Usuario (ID= 1..N-1){
	boolean esAcniano = esAnciano()
	Cajero.llegaCajero(esAnciano);
	UsarCajero()
	Cajero.salirCajero();
}


Ej 4-
En un banco hay 3 empleados. Y hay N clientes que deben ser atendidos por uno de ellos (cualquiera) de acuerdo al orden de llegada. Cuando uno de los empleados lo atiende el cliente le entrega los papeles y espera el resultado.

Monitor Admin {
	cola Espera;
	cond Turno[N];
	cond entro_cliente;
	Text Respuestas[N];
	
	Procedure llego (int IN DNI, text IN datos, text OUT respuesta){
		Push (Espera, (ID, datos));
		Signal (entro_cliente);
		Wait (Turno[ID])
		respuesta = Respuestas[ID];
	}


	Procedure atender (int OUT cliente, text OUT datos) {
		while (empty(Espera)) wait(entro_cliente)
		Pop (Espera (cliente, datos)		
	}

	Procedure responder (int IN cliente, text IN respuesta){
		Respuestas[cliente] = respuesta;
		signal (Turno[cliente])	
	}
	
}

Process Usuario (ID = 0..N-1) {
	int ID
	text dato, respuesta;
	Admin.llego(ID, dato, respuesta)

}


Process empleado (ID = 0..2) {
	int usuario;
	text dato, respuesta;
	while (true){
		Admin.atender (usuario, dato)
		respuesta = AalizarDato(dato)
		Admin.responder (usuario, respuesta);
	}
}

Resolucion alterna, del modo de la practica con 2 monitores escritorio y mesa y 2 procesos usuario y empleado

Monitor Banco {
	cola listaEspera;
	cond llegoNuevo;
	int escritorioDisponible[N];
	cond turno[N];
	

	procedure pedirTuno (int IN id, int OUT nEscritorio){
		Push (cola, id);
		signal (llegoNuevo);
		await (turno[id])
		nEscritorio = escritorioDisponible[id]
	}


	procedure siguienteTurno (int IN n) {
		int usuario;
		while (empty(listaEspera)) await (llegoNuevo)
		Pop (listaEspera, usuario)
		escritorioDisponible[usuario] = n;
		signal (turno[N]);
	}

}


Monitor Escritorio [n: 0..2]{
	cond llegoUsuario;
	cond respuestaEnviada;
	cond respuestaRecibida 
	text datosEntregados;
	text respuestaPedido;

	procedure entregarDatos (text IN datos, text OUT respuesta) {
		datosEntregados = datos;
		signal (llegoUsuario);
		await (respuestaEnviada)
		respuesta = respuestaPedido;
		signal (respuestaRecibida)		
	}


	procedure solicitarDatos(text OUT datos) {
		Banco.siguienteTurno(n);
		wait (llegoUsuario);
		datos = datosEntregados;
	}

	procedure mandarRespuesta (text IN respuesta){
		respuestaPedido = respuesta
		signal (respuestaEnviada);
		await (respuestaRecibida);

	}

}


Process usuario [id: 0..N-1]{
	text datos, respuesta;
	int nEscritorio;
	datos: getDatos();
	Banco.pedirTurno(id, nEscritorio)
	Escritorio[nEscritorio].entregarDatos(datos, respuesta);

}

Process empleado [id: 0..2]{
	text datos, respuesta;
	while (true) {
		Escritorio[id].solicitarDatos(datos)
		ResolverPedido (datos, respuesta)
		Escritorio[id].mandarRespuesta(respuesta);
	}
}




EJ 5-

Se debe simular un partido de fútbol 11. Cuando los 22 jugadores llegaron a la
cancha juegan durante 90 minutos y luego todos se retiran.



Monitor Server () {
	int jugadores = 0;
	cond esperando;
	cond faltan;
	cond termino_partido;

	Procedure llegoJugador () {
		jugadores = jugadores + 1;
		if (jugadores = 22) signal(faltan)
		wait (esperando)
		//jugado partido
		wait (termino_partido)
	}

	Procedure iniciarPartido () {
		if (jugadores < 22) await (faltan)
		signal_all (esperando)
		
	}
	
	Procedure terminoPartido(){
		signal_all(termino_partido)
	}

}



Process jugador (ID: 0..N-1) {
	Server.llegoJugador()
	

}


Process cancha () {
	Server.iniciarPartido()
	delay(90 mins)
	Server.terminoPartido()

}


Ej 6-

En una empresa de genética hay N clientes que envían secuencias de ADN para
que sean analizadas y esperan los resultados para poder continuar. Para resolver
estos análisis la empresa cuenta con un servidor que resuelve los pedidos de
acuerdo al orden de llegada de los mismos.

monitor Admin {	
	cola secuencias;
	cond libre;
	cond listaDeEspera;
	int cantEspera = 0;
	text repuestas[N];

	Process llego (text IN secuencia, int IN ID, text OUT resultado) {
		Push (secuencias, (secuencia, ID))
		cantEspera  = cantEspera + 1
		signal (libre);
		wait (listaDeEspera)
		resultado = respuestas[ID];
		
		
		
	}

	Process getSecuencia (int OUT ID, text OUT secuencia){
		if (not cantEspera > 0) await (libre) 		
		Pop (secuencias, (secuencia, ID)
		cantEspera = cantEspera - 1; 
	}

	Process setResultado (int IN ID, string IN resultado){
		respuestas[ID] = resultado
		signal (listaDeEspera)

	}

}



process User (id: 0..N-1){
	text secuencia, resultado
	while (true) {
		generarSecuencia(secuencia)
		Admin.llego(secuencia, id, resultado)		
	}
}



process Servidor () {
	text secuencia, resultado
	int id
	while (true){
		Admin.getSecuencia(ID, secuencia)
		analizarSecuencia (secuencia, resultado)
		Admin.setResultado(ID, resultado)
	}
}

Ej 7-
Modificamos el enunciado para que haya 2 servidores en lugar de 1. Y partimos
de la solución anterior

//EL CANT ESPERA ES INNECESARIO PODRIA CHECKEAR EMPTY(SECUENCIAS) PERO YA LO HABIA HECHO CON LA VARIABLE CONTADOR

monitor Admin {	
	cola secuencias;
	cond libre;
	cond listaDeEspera[N];
	int cantEspera = 0;
	text repuestas[N];

	Process llego (text IN secuencia, int IN ID, text OUT resultado) {
		Push (secuencias, (secuencia, ID))
		cantEspera  = cantEspera + 1
		signal (libre);
		wait (listaDeEspera[ID])
		resultado = respuestas[ID];
		
		
		
	}

	Process getSecuencia (int OUT ID, text OUT secuencia){
		while (not cantEspera > 0) wait (libre) 		
		Pop (secuencias, (secuencia, ID)
		cantEspera = cantEspera - 1; 
	}

	Process setResultado (int IN ID, string IN resultado){
		respuestas[ID] = resultado
		signal (listaDeEspera[ID])

	}

}



process User (id: 0..N-1){
	text secuencia, resultado
	while (true) {
		generarSecuencia(secuencia)
		Admin.llego(secuencia, id, resultado)		
	}
}



process Servidor (ID: 0..1) {
	text secuencia, resultado
	int usuario
	while (true){
		Admin.getSecuencia(usuario, secuencia)
		analizarSecuencia (secuencia, resultado)
		Admin.setResultado(usuario, resultado)
	}
}








Ej practica-
En un entrenamiento de futbol hay 20 jugadores que forman 4 equipos (cada
jugador conoce el equipo al cual pertenece llamando a la función DarEquipo()).
Cuando un equipo está listo (han llegado los 5 jugadores que lo componen),
debe enfrentarse a otro equipo que también esté listo (los dos primeros equipos 
en juntarse juegan en la cancha 1, y los otros dos equipos juegan en la cancha 2). 
Una vez que el equipo conoce la cancha en la que juega, sus jugadores se dirigen
a ella. Cuando los 10 jugadores del partido llegaron a la cancha comienza el
partido, juegan durante 50 minutos, y al terminar todos los jugadores del partido
se retiran (no es necesario que se esperen para salir).



Monitor server () {
	jugadores_equipo [4] = 0..3=0;
	int equipo_completo;
	cola esperando;
	cond cancha_lista;
	cond arranca[4];
	int canchas [4] = 0..3 = 0;
	cond termina_cancha[2];
	cancha_actual= 1;
	
	Procedure llegaJugador (int IN equipo, int OUT cancha) {
		
		jugadores_equipo[equipo] = jugadores_equipo[equipo] + 1;
		if (jugadores_equipo[equipo] = 5)  {equipo_completo = equipo_completo + 1}
		if (equipo_completo = 2) {
			Push (esperando, equipo);
			signal(cancha_lista)
		}
		await (arranca[equipo])
		cancha = canchas[equipo];
	}

	Procedure jugarCancha (int IN cancha){
		//juganco
		await (termina_cancha[cancha])
	}
	
	Procedure esperandoEquipos (int OUT cancha){
		int equipo;
		while ( equipo_completo < 2) await (cancha_lista)
		equipo_completo = equipo_completo - 2;
		Pop(esperando, equipo)
		canchas[equipo] = cancha_actual;
		signal_all(arranca[equipo])
		Pop(esperando, equipo)
		canchas[equipo] = cancha_actual;
		signal_all(arranca[equipo])
		cancha_actual = cancha_actual + 1;	
	}


	Procedure termino (int IN cancha){
		singall_all(termina_cancha[cancha])
	}
	

}

Process jugador (ID= 0..19){
	int cancha;
	equipo = DarEquipo()
	server.llegaJugador(ID, cancha)
	
	server.jugarCancha(cancha)
}


Process cancha (0..1){
	server.esperandoEquipos(N);
	delay(50 mins)
	server.termino(N)
	
}






//REMAKE CON LOS MONITOPRES Y PROCESOS QUE LO HICIERON LOS JTP monitor: Equipo, Admin, Cancha Process: partido, jugador


Monitor Equipo [id: 0..3] {
	

}


Monitor Admin {

}


Monitor Cancha [id: 0..1]{


}


Process Partido [id: 0..1]{


}


Process Jugador [id: 0..19]{


}

































